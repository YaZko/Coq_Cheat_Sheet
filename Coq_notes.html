<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-02-19 Fri 17:31 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Index</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Platypus" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Index</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline7">1. Computation</a>
<ul>
<li><a href="#orgheadline4">1.1. Eval</a>
<ul>
<li><a href="#orgheadline1">1.1.1. Compute</a></li>
<li><a href="#orgheadline2">1.1.2. cbv</a></li>
<li><a href="#orgheadline3">1.1.3. cbn (8.5)</a></li>
</ul>
</li>
<li><a href="#orgheadline5">1.2. Simpl</a></li>
<li><a href="#orgheadline6">1.3. Reflexivity</a></li>
</ul>
</li>
<li><a href="#orgheadline10">2. Intro patterns</a>
<ul>
<li><a href="#orgheadline8">2.1. With square brackets</a></li>
<li><a href="#orgheadline9">2.2. Tricks</a></li>
</ul>
</li>
<li><a href="#orgheadline13">3. Notations</a>
<ul>
<li><a href="#orgheadline11">3.1. Precedence levels</a></li>
<li><a href="#orgheadline12">3.2. Associativity</a></li>
</ul>
</li>
<li><a href="#orgheadline14">4. The Case tactic</a></li>
<li><a href="#orgheadline17">5. Arguments</a>
<ul>
<li><a href="#orgheadline15">5.1. Implicit arguments</a></li>
<li><a href="#orgheadline16">5.2. Arguments renaming</a></li>
</ul>
</li>
<li><a href="#orgheadline18">6. Generalize dependent versus generalize versus revert</a></li>
<li><a href="#orgheadline22">7. Duplicating an hypothesis</a>
<ul>
<li><a href="#orgheadline19">7.1. With remember</a></li>
<li><a href="#orgheadline20">7.2. With generalize dependent</a></li>
<li><a href="#orgheadline21">7.3. With assert</a></li>
</ul>
</li>
<li><a href="#orgheadline29">8. Working with Ltac</a>
<ul>
<li><a href="#orgheadline25">8.1. Matching on hypotheses and conclusions</a>
<ul>
<li><a href="#orgheadline23">8.1.1. Hypotheses</a></li>
<li><a href="#orgheadline24">8.1.2. Conclusions</a></li>
</ul>
</li>
<li><a href="#orgheadline26">8.2. Generate fresh names</a></li>
<li><a href="#orgheadline27">8.3. Print Ltac</a></li>
<li><a href="#orgheadline28">8.4. Working with PG</a></li>
</ul>
</li>
<li><a href="#orgheadline30">9. Show the axioms used for a given lemma</a></li>
<li><a href="#orgheadline33">10. Using tactics like reflexivity over user built relations</a>
<ul>
<li><a href="#orgheadline31">10.1. Adding equivalence relations, preorder, etc&#x2026;</a></li>
<li><a href="#orgheadline32">10.2. Adding morphisms</a></li>
</ul>
</li>
<li><a href="#orgheadline34">11. <span class="todo nilTODO">TODO</span> : pattern matching. Unify with intro patterns and talk about the let, let with the backstick</a></li>
<li><a href="#orgheadline35">12. <span class="todo nilTODO">TODO</span> : switching goals</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">1</span> Computation</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.1</span> Eval</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1"><span class="section-number-4">1.1.1</span> Compute</h4>
</div>
<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2"><span class="section-number-4">1.1.2</span> cbv</h4>
</div>
<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3"><span class="section-number-4">1.1.3</span> cbn (8.5)</h4>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.2</span> Simpl</h3>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">1.3</span> Reflexivity</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Reflexivity does more than simpl, it notably tries to unfold definitions.
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><span class="section-number-2">2</span> Intro patterns</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">2.1</span> With square brackets</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Conjunction: just a list with no separators
Ex: <code>[H1 [H2 H3]]</code> or <code>(H1 &amp; H2 &amp; H3)</code>
Disjunction: <code>|</code>
Ex: <code>[H1 | H2]</code>
</p>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">2.2</span> Tricks</h3>
<div class="outline-text-3" id="text-2-2">
<p>
&lt;- or -&gt; to rewrite directly an equality.
_ clear the hypothesis directly
? to let coq choose the name
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">3</span> Notations</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">3.1</span> Precedence levels</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Go from 0 (tightest) to 100, with an additionnal special 200.
</p>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">3.2</span> Associativity</h3>
<div class="outline-text-3" id="text-3-2">
<p>
No associativity
Left associativity
Right associativity
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">4</span> The Case tactic</h2>
<div class="outline-text-2" id="text-4">
<p>
From Software Foundation, used to keep track of the ongoing case
</p>

<div class="org-src-container">

<pre class="src src-coq">Require String. Open Scope string_scope.

Ltac move_to_top x :=
match reverse goal with
| H : _ | - _ =&gt; try move x after H |
end.

Tactic Notation "assert_eq" ident(x) constr(v) :=
let H := fresh in
assert (x = v) as H by reflexivity;
clear H.

Tactic Notation "Case_aux" ident(x) constr(name) :=
first [
set (x := name); move_to_top x
| assert_eq x name; move_to_top x
| fail 1 "because we are working on a different case" ].

Tactic Notation "Case" constr(name) := Case_aux Case name.
Tactic Notation "SCase" constr(name) := Case_aux SCase name.
Tactic Notation "SSCase" constr(name) := Case_aux SSCase name.
Tactic Notation "SSSCase" constr(name) := Case_aux SSSCase name.
Tactic Notation "SSSSCase" constr(name) := Case_aux SSSSCase name.
Tactic Notation "SSSSSCase" constr(name) := Case_aux SSSSSCase name.
Tactic Notation "SSSSSSCase" constr(name) := Case_aux SSSSSSCase name.
Tactic Notation "SSSSSSSCase" constr(name) := Case_aux SSSSSSSCase name.
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17"><span class="section-number-2">5</span> Arguments</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">5.1</span> Implicit arguments</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Implicit arguments are treated the same way as if provided as an _, but systematically.
We can declare them at define time by putting curly brackets around the argument.
</p>

<div class="org-src-container">

<pre class="src src-coq">Inductive list {A : Type} : Type :=
 | nil : list
 | cons : A -&gt; list -&gt; list.
</pre>
</div>

<p>
Afterwards, through the Arguments directive: name and list of arguments, curly
brackets for the ones to be inferred.
</p>

<p>
Use an @ to disable implicit arguments locally.
</p>

<div class="org-src-container">

<pre class="src src-coq">Definition l : @list nat := ... .
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">5.2</span> Arguments renaming</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Arguments can be used to rename arguments using the rename flag (:rename. at the end of the command).
(PW: explain? example?)
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><span class="section-number-2">6</span> Generalize dependent versus generalize versus revert</h2>
<div class="outline-text-2" id="text-6">
<p>
Starting from a goal
</p>
<div class="org-src-container">

<pre class="src src-coq">a, b : A
EQ : a = b
---------
  b = a
</pre>
</div>

<p>
One can use different tactics to move hypotheses from the context to the goal.
</p>

<div class="org-src-container">

<pre class="src src-coq">revert EQ

a, b : A
---------
a = b -&gt; b = a
</pre>
</div>
<p>
OR
</p>
<div class="org-src-container">

<pre class="src src-coq">generalize EQ

a, b : A
EQ : a = b
---------
a = b -&gt; b = a
</pre>
</div>

<p>
Notice that the generalized hypothesis is still present in the context, contrary to the reverted one.
</p>

<p>
We can also generalize terms of type in Type.
</p>

<div class="org-src-container">

<pre class="src src-coq">generalize a

a, b : A
EQ : a = b
---------
forall a0: A, b = a0
</pre>
</div>

<p>
Here we have lost some information, because the <code>a</code> in the context is no longer related to the new one.
This situation is solved using generalize dependent.
</p>

<div class="org-src-container">

<pre class="src src-coq">generalize dependent a

b : A
---------
forall a : A, a = b -&gt; b = a
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22"><span class="section-number-2">7</span> Duplicating an hypothesis</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">7.1</span> With remember</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-coq">Ltac dup H :=
let H' := fresh "H" in
remember H as H'; clear HeqH'.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">7.2</span> With generalize dependent</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">

<pre class="src src-coq">Ltac dup H :=
let H' := fresh "H" in
generalize dependent H; intros H'.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">7.3</span> With assert</h3>
<div class="outline-text-3" id="text-7-3">
<div class="org-src-container">

<pre class="src src-coq">Ltac dup H :=
let n := fresh H in
assert (n := H)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline29" class="outline-2">
<h2 id="orgheadline29"><span class="section-number-2">8</span> Working with Ltac</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25"><span class="section-number-3">8.1</span> Matching on hypotheses and conclusions</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23"><span class="section-number-4">8.1.1</span> Hypotheses</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Looking for an hypothesis of the form P x y, for any x and y.
</p>

<div class="org-src-container">

<pre class="src src-coq">match goal with
  H : P ?x ?y |- _ =&gt; destruct H; auto
end.
</pre>
</div>
<p>
This will fail if no such hypothesis exists.
You can add <code>try</code> in front of it.
</p>

<p>
To match <b>all</b> such hypotheses, add <code>repeat</code>.
</p>

<p>
The following example shows how to use hypotheses matching to remove duplicates in hypotheses.
</p>

<div class="org-src-container">

<pre class="src src-coq">Goal P x y -&gt; P x y -&gt; P x z -&gt; P x z -&gt; P x z -&gt; P y z.
Proof.
  intros.

  repeat match goal with
    H1 : P ?x ?y,
	H2: P ?x ?y |- _ =&gt; clear H1
  end.
Qed.
</pre>
</div>

<p>
We try to match two hypotheses of the form <code>P ?x ?y</code>. The pattern matching is
 strong enough to express that H1 and H2 must refer to the same x and y.
H1 and H2 are guaranteed to be different though.
</p>

<p>
It is also possible to match part of an hypothesis.
Using <code>context</code>:
</p>
<div class="org-src-container">

<pre class="src src-coq">match goal with
  H : context [P ?x ?y] |- _ =&gt; (* do stuff *)
end.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24"><span class="section-number-4">8.1.2</span> Conclusions</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
The matching can also be made on the conlusion of the goal (after <code>|-</code>):
</p>
<div class="org-src-container">

<pre class="src src-coq">match goal with
  |- context [P ?x ?y] =&gt; (* do stuff *)
end.
</pre>
</div>

<p>
Of course, multiple patterns can be matched.
</p>
<div class="org-src-container">

<pre class="src src-coq">repeat match goal with
  H : context [P ?x ?y] |- _ =&gt; (* do stuff *)
| |- context [P ?x ?y] =&gt; (* do stuff *)
end.
</pre>
</div>
<p>
This will loop as long as either the hypotheses or the conclusion contain a term matching <code>P ?x ?y</code>.
Be sure to remove the matching hypotheses to enforce termination.
</p>
</div>
</div>
</div>



<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26"><span class="section-number-3">8.2</span> Generate fresh names</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Sometimes we need to generate fresh names inside tactics:
</p>
<div class="org-src-container">

<pre class="src src-coq">let n := fresh in (* generate new name, probably H0, H1, H2 *)
intro n

let n := fresh H in (* generate new name, based on the name of H *)
intro n

let n := fresh "H" in (* generate new name, based on the given string "H" *)
intro n
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27"><span class="section-number-3">8.3</span> Print Ltac</h3>
<div class="outline-text-3" id="text-8-3">
<p>
One can view the Ltac code of a tactic (when it's actually written in Ltac).
</p>
<div class="org-src-container">

<pre class="src src-coq">Print Ltac inv.

---&gt;
Ltac inv H := inversion H; clear H; subst
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28"><span class="section-number-3">8.4</span> Working with PG</h3>
<div class="outline-text-3" id="text-8-4">
<p>
One can add custom keybindings to Emacs / PG.
For example, to see the Ltac code of a tactic (see previous section), we can define the following Emacs lisp code in the appropriate file (~/.emacs= in my case)
</p>

<div class="org-src-container">

<pre class="src src-elisp">(defun coq-Print-Ltac (withprintingall)
  "Ask for a tactic and Print Ltac it."
  (interactive "P")
  (if withprintingall
      (coq-ask-do-show-all "Print Ltac" "Print Ltac")
    (coq-ask-do "Print Ltac" "Print Ltac")))

(global-set-key (kbd "C-c C-$") 'coq-Print-Ltac)
</pre>
</div>

<p>
(PW: I should investigate what occurences of "Print Ltac" stand for what)
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline30" class="outline-2">
<h2 id="orgheadline30"><span class="section-number-2">9</span> Show the axioms used for a given lemma</h2>
<div class="outline-text-2" id="text-9">
<p>
To show what axioms a given lemma depends on, one can use the following vernacular command
</p>

<div class="org-src-container">

<pre class="src src-coq">Print Assumptions my_lemma.
</pre>
</div>
</div>
</div>


<div id="outline-container-orgheadline33" class="outline-2">
<h2 id="orgheadline33"><span class="section-number-2">10</span> Using tactics like reflexivity over user built relations</h2>
<div class="outline-text-2" id="text-10">
<p>
The goal here is to be able to use coq's built-in tactics over other relations
than iff and eq, in particular relations that you have defined yourself.
</p>
</div>
<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31"><span class="section-number-3">10.1</span> Adding equivalence relations, preorder, etc&#x2026;</h3>
<div class="outline-text-3" id="text-10-1">
<p>
The inner mechanism going on when using tactics like reflexivity,
transitivity or symmetry is typeclasses. However coq allows a particular
facility to declare new relation without digging into this.  The syntax goes
roughly as follows:
</p>

<div class="org-src-container">

<pre class="src src-coq">Add Parametric Relation (A: Type): A (@R A)
reflexivity proved by ...
symmetry proved by ...
transitivity proved by ...
as R_is_an_equivalence_relation.
</pre>
</div>

<p>
Note that you naturally only want to take A as a parameter if your relation
is indeed polymorphic.  For instance, suppose you need to manipulate
predicates over program states up to propositional extentional
equivalence. This relation is an equivalence relation, so you might want to
declare it as so.
</p>

<div class="org-src-container">

<pre class="src src-coq">Axiom state: Type.
Definition Pred: state -&gt; Prop.
Definition PEq (P1 P2: Pred): Prop := forall x, P1 x &lt;-&gt; P2 x.
Lemma PEq_reflexive: forall P, P ≡ P.
Proof.
  intros P s; go.
Qed.

Lemma PEq_trans: forall P1 P2 P3 (H1: P1 ≡ P2) (H2: P2 ≡ P3),
    P1 ≡ P3.
  intros P1 P2 P3 H1 H2 s; split; intros H3; [apply H2, H1 | apply H1,H2]; assumption.
Qed.

Lemma PEq_symm: forall P1 P2 (H: P1 ≡ P2), P2 ≡ P1.
Proof.
  intros P1 P2 H s; split; intros H'; apply H; assumption.
Qed.

Add Parametric Relation: Pred PEq
    reflexivity proved by PEq_reflexive
    symmetry proved by PEq_symm
    transitivity proved by PEq_trans
      as PEq_equiv.
</pre>
</div>

<p>
We now are able to prove goals such that <code>(forall P: Pred, PEq P P)</code> with a
simpl (<code>intros P; reflexivity</code>). Same goes for <code>transitivity</code> and <code>symmetry</code>.
</p>

<p>
Note that we can also only declare some of those properties, declaring that a
relation is a preorder for instance:
</p>

<div class="org-src-container">

<pre class="src src-coq">Definition PWeaker (P1 P2: Pred): Prop := forall s, P2 s -&gt; P1 s.

Lemma PWeaker_reflexive: forall P, P ⊆ P.
Proof.
  go.
Qed.

Lemma PWeaker_trans: forall P1 P2 P3 (H1: P1 ⊆ P2) (H2: P2 ⊆ P3), P1 ⊆ P3.
Proof.
  intros P1 P2 P3 H1 H2 s H3; apply H1,H2,H3.
Qed.

Add Parametric Relation: Pred PWeaker
    reflexivity proved by PWeaker_reflexive
    transitivity proved by PWeaker_trans
      as PWeaker_preorder.
</pre>
</div>

<p>
In this case naturally <code>symmetry</code> will not work.  Note that you are not
required to provide the appropriate proof term directly in the relation
declaration, you may use wildcards for coq to require the proofs
interactively.
</p>

<p>
Remark: As said earlier, what is really going on is the typeclass
mechanism. So all this is simply sugar for an instance declaration to the
appropriate type class, Equivalence for example in the first case. We could
have written instead:
</p>

<div class="org-src-container">

<pre class="src src-coq">Require Import Classes.RelationClasses.

Instance PEq_equiv: @Equivalence Pred PEq :=
 Equivalence_Reflexive := PEq_reflexive
 Equivalence_Symmetric := PEq_symm
 Equivalence_Transitive := PEq_trans.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32"><span class="section-number-3">10.2</span> Adding morphisms</h3>
<div class="outline-text-3" id="text-10-2">
<p>
The other typical case in which you might want to extend built-in tactics is
the one of morphisms for which we would like to be able to use
<code>rewrite</code>. Once again, we have syntactic sugar to avoir bothering explicitely
with typeclasses.  In the case of a binary function, it would look like this:
</p>

<div class="org-src-container">

<pre class="src src-coq">Add Parametric Morphism : f with
   signature (rel ==&gt; rel ==&gt; rel) as foo.
</pre>
</div>

<p>
This one might seem a bit more cryptic. What is going on is that given a
context, we want to be able to substitute a subterm for an other one given
they are related by the relation rel. Said differently, we want to prove that
f is a morphism with respect to rel, or that rel is compatible with f.
</p>

<p>
It is clearer with an example. Say we define the union of two predicates, we
can actually rewrite any equivalent predicates under it.
</p>

<div class="org-src-container">

<pre class="src src-coq">Require Import Setoid.
Definition PJoin P1 P2: Pred := λ s, P1 s \/ P2 s.

Add Parametric Morphism : PJoin with
   signature (PEq ==&gt; PEq ==&gt; PEq) as foo.
Proof.
  intros Q1 Q1' eq1 Q2 Q2' eq2 s; split; intros H;
    (destruct H; [left; apply eq1; assumption | right; apply eq2; assumption]).
Qed.
</pre>
</div>

<p>
coq asked us to prove that if four predicates are pairwise PEquivalent, their
respective unions are PEquivalent. We therefore now are able to use the
tactic <code>rewrite</code> to rewrite PEquivalences under unions in goals.
</p>

<p>
Note: beware, we only proved the compatibility of PEq with respect to the
union!  coq will complain if we try to rewrite PEquivalence under any other
construction. The (Leibniz) equality has the peculiar property to be
compatible with any context by definition.  
</p>

<p>
Note bis: we have a very symmetric statement in the exemple using PEq
everywhere, but that is not necessary. We could for instance assert
compatibility only on the left by replacing the second PEq by an eq. An other
reason of uniformity in the example is that the codomain of the function
PJoin is the same as its arguments, but once again it could be otherwise. It
notably is common to end up in Prop and therefore be interested in a result
where the last PEq is replaced by iff: the proposition obtained after
rewriting is guaranteed to be equivalent.
</p>

<p>
Finally, as was the case with relations, we can instead explicitely declare
the adequate instance. The Typeclass at use here is Proper:
</p>

<div class="org-src-container">

<pre class="src src-coq">Instance foo: Proper (PEq ==&gt; PEq ==&gt; PEq) PJoin.
Proof.
  intros Q1 Q1' eq1 Q2 Q2' eq2 s; split; intros H;
    (destruct H; [left; apply eq1; assumption | right; apply eq2; assumption]).
Qed.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-2">
<h2 id="orgheadline34"><span class="section-number-2">11</span> <span class="todo TODO">TODO</span> : pattern matching. Unify with intro patterns and talk about the let, let with the backstick</h2>
</div>

<div id="outline-container-orgheadline35" class="outline-2">
<h2 id="orgheadline35"><span class="section-number-2">12</span> <span class="todo TODO">TODO</span> : switching goals</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Platypus</p>
<p class="date">Created: 2016-02-19 Fri 17:31</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
