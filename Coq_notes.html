<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Index</title>
<!-- 2016-03-04 Fri 17:47 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Platypus" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Index</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Useful user-defined tactics</a>
<ul>
<li><a href="#sec-1-1">1.1. The Case tactic</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Automatization facilities</a>
<ul>
<li><a href="#sec-2-1">2.1. Using tactics like reflexivity over user built relations</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. Adding equivalence relations, preorder, etc&#x2026;</a></li>
<li><a href="#sec-2-1-2">2.1.2. Adding morphisms</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. Using hint databases</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. Hint databases from the standard library</a></li>
<li><a href="#sec-2-2-2">2.2.2. User-defined databases</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3. Computation</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. Compute</a></li>
<li><a href="#sec-2-3-2">2.3.2. cbv</a></li>
<li><a href="#sec-2-3-3">2.3.3. cbn</a></li>
<li><a href="#sec-2-3-4">2.3.4. Simpl</a></li>
<li><a href="#sec-2-3-5">2.3.5. NoteReflexivity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Notations</a>
<ul>
<li><a href="#sec-3-1">3.1. Useful notations from the standard library</a></li>
<li><a href="#sec-3-2">3.2. Precedence levels</a></li>
<li><a href="#sec-3-3">3.3. Associativity</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Working with Ltac</a>
<ul>
<li><a href="#sec-4-1">4.1. Matching on hypotheses and conclusions</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1. Hypotheses</a></li>
<li><a href="#sec-4-1-2">4.1.2. Conclusions</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. Generate fresh names</a></li>
<li><a href="#sec-4-3">4.3. Print Ltac</a></li>
<li><a href="#sec-4-4">4.4. Working with PG</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Miscellaneous useful tricks</a>
<ul>
<li><a href="#sec-5-1">5.1. Keeping track of the ongoing case</a></li>
<li><a href="#sec-5-2">5.2. Duplicating an hypothesis</a>
<ul>
<li><a href="#sec-5-2-1">5.2.1. With remember</a></li>
<li><a href="#sec-5-2-2">5.2.2. With generalize dependent</a></li>
<li><a href="#sec-5-2-3">5.2.3. With assert</a></li>
</ul>
</li>
<li><a href="#sec-5-3">5.3. Show the axioms used for a given lemma</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Arguments</a>
<ul>
<li><a href="#sec-6-1">6.1. Implicit arguments</a></li>
<li><a href="#sec-6-2">6.2. Arguments renaming</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Generalize dependent versus generalize versus revert</a></li>
<li><a href="#sec-8">8. Intro patterns</a>
<ul>
<li><a href="#sec-8-1">8.1. With square brackets</a></li>
<li><a href="#sec-8-2">8.2. Tricks</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Pattern matching. Unify with intro patterns and talk about the let, let with the backstick</a>
<ul>
<li><a href="#sec-9-1">9.1. A particular case of pattern matching, the let-binding</a></li>
</ul>
</li>
<li><a href="#sec-10">10. Switching and selecting goals</a>
<ul>
<li><a href="#sec-10-1">10.1. Switching to a specific goal</a></li>
<li><a href="#sec-10-2">10.2. Goal selectors.</a>
<ul>
<li><a href="#sec-10-2-1">10.2.1. In 8.5, the all: selector</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-11">11. Emacs extensions: Proof-General and Company-coq</a>
<ul>
<li><a href="#sec-11-1">11.1. Proof-General</a></li>
<li><a href="#sec-11-2">11.2. Company-coq</a></li>
</ul>
</li>
<li><a href="#sec-12">12. <span class="todo TODO">TODO</span> : PG, companycoq, useful commands</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Useful user-defined tactics</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> The Case tactic</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Taken from Pierce's Software Foundation, it can be used to document a proof by annotating the proof context with the ongoing case.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Require</span> String. <span class="org-keyword">Open Scope</span> string_scope.

<span class="org-keyword">Ltac</span> <span class="org-function-name">move_to_top</span> x :=
<span class="org-type">match</span> reverse goal <span class="org-type">with</span>
| H : _ | - _ =&gt; <span class="org-proof-tacticals-name">try</span> <span class="org-proof-tactics-name">move</span> x <span class="org-type">after</span> H |
<span class="org-type">end</span>.

<span class="org-keyword">Tactic Notation</span> <span class="org-string">"assert_eq"</span> ident(x) constr(v) :=
<span class="org-type">let</span> H := fresh <span class="org-type">in</span>
<span class="org-proof-tactics-name">assert</span> (x = v) <span class="org-type">as</span> H <span class="org-coq-solve-tactics">by</span> <span class="org-coq-solve-tactics">reflexivity</span>;
<span class="org-proof-tactics-name">clear</span> H.

<span class="org-keyword">Tactic Notation</span> <span class="org-string">"Case_aux"</span> ident(x) constr(name) :=
<span class="org-proof-tacticals-name">first</span> [
<span class="org-proof-tactics-name">set</span> (x := name); move_to_top x
| assert_eq x name; move_to_top x
| <span class="org-keyword">fail</span> 1 <span class="org-string">"because we are working on a different case"</span> ].

<span class="org-keyword">Tactic Notation</span> <span class="org-string">"Case"</span> constr(name) := Case_aux Case name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SCase"</span> constr(name) := Case_aux SCase name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SSCase"</span> constr(name) := Case_aux SSCase name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SSSCase"</span> constr(name) := Case_aux SSSCase name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SSSSCase"</span> constr(name) := Case_aux SSSSCase name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SSSSSCase"</span> constr(name) := Case_aux SSSSSCase name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SSSSSSCase"</span> constr(name) := Case_aux SSSSSSCase name.
<span class="org-keyword">Tactic Notation</span> <span class="org-string">"SSSSSSSCase"</span> constr(name) := Case_aux SSSSSSSCase name.
</pre>
</div>
</div>
</div>
</div>





<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Automatization facilities</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Using tactics like reflexivity over user built relations</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The goal here is to be able to use coq's built-in tactics over other relations
than iff and eq, in particular relations that you have defined yourself.
</p>
</div>
<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Adding equivalence relations, preorder, etc&#x2026;</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
The inner mechanism going on when using tactics like reflexivity,
transitivity or symmetry is typeclasses. However coq allows a particular
facility to declare new relation without digging into this.  The syntax goes
roughly as follows:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Add Parametric Relation</span> (<span class="org-variable-name">A</span>: <span class="org-type">Type</span>): A (@R A)
<span class="org-coq-solve-tactics">reflexivity</span> proved <span class="org-coq-solve-tactics">by</span> ...
<span class="org-proof-tactics-name">symmetry</span> proved <span class="org-coq-solve-tactics">by</span> ...
<span class="org-proof-tactics-name">transitivity</span> proved <span class="org-coq-solve-tactics">by</span> ...
<span class="org-type">as</span> R_is_an_equivalence_relation.
</pre>
</div>

<p>
Note that you naturally only want to take A as a parameter if your relation
is indeed polymorphic.  For instance, suppose you need to manipulate
predicates over program states up to propositional extentional
equivalence. This relation is an equivalence relation, so you might want to
declare it as so.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Axiom</span> <span class="org-variable-name">state</span>: <span class="org-type">Type</span>.
<span class="org-keyword">Definition</span> <span class="org-function-name">Pred</span>: state -&gt; <span class="org-type">Prop</span>.
<span class="org-keyword">Definition</span> <span class="org-function-name">PEq</span> (<span class="org-variable-name">P1 P2</span>: Pred): <span class="org-type">Prop</span> := <span class="org-type">forall</span> <span class="org-variable-name">x</span>, P1 x &lt;-&gt; P2 x.
<span class="org-keyword">Lemma</span> <span class="org-function-name">PEq_reflexive</span>: <span class="org-type">forall</span> <span class="org-variable-name">P</span>, P &#8801; P.
<span class="org-keyword">Proof</span>.
  <span class="org-proof-tactics-name">intros</span> P s; go.
<span class="org-keyword">Qed</span>.

<span class="org-keyword">Lemma</span> <span class="org-function-name">PEq_trans</span>: <span class="org-type">forall</span> P1 P2 P3 (<span class="org-variable-name">H1</span>: P1 &#8801; P2) (<span class="org-variable-name">H2</span>: P2 &#8801; P3),
    P1 &#8801; P3.
  <span class="org-proof-tactics-name">intros</span> P1 P2 P3 H1 H2 s; <span class="org-proof-tactics-name">split</span>; <span class="org-proof-tactics-name">intros</span> H3; [<span class="org-proof-tactics-name">apply</span> H2, H1 | <span class="org-proof-tactics-name">apply</span> H1,H2]; <span class="org-coq-solve-tactics">assumption</span>.
<span class="org-keyword">Qed</span>.

<span class="org-keyword">Lemma</span> <span class="org-function-name">PEq_symm</span>: <span class="org-type">forall</span> P1 P2 (<span class="org-variable-name">H</span>: P1 &#8801; P2), P2 &#8801; P1.
<span class="org-keyword">Proof</span>.
  <span class="org-proof-tactics-name">intros</span> P1 P2 H s; <span class="org-proof-tactics-name">split</span>; <span class="org-proof-tactics-name">intros</span> H'; <span class="org-proof-tactics-name">apply</span> H; <span class="org-coq-solve-tactics">assumption</span>.
<span class="org-keyword">Qed</span>.

<span class="org-keyword">Add Parametric Relation</span>: Pred PEq
    <span class="org-coq-solve-tactics">reflexivity</span> proved <span class="org-coq-solve-tactics">by</span> PEq_reflexive
    <span class="org-proof-tactics-name">symmetry</span> proved <span class="org-coq-solve-tactics">by</span> PEq_symm
    <span class="org-proof-tactics-name">transitivity</span> proved <span class="org-coq-solve-tactics">by</span> PEq_trans
      <span class="org-type">as</span> PEq_equiv.
</pre>
</div>

<p>
We now are able to prove goals such that <code>(forall P: Pred, PEq P P)</code> with a
simpl (<code>intros P; reflexivity</code>). Same goes for <code>transitivity</code> and <code>symmetry</code>.
</p>

<p>
Note that we can also only declare some of those properties, declaring that a
relation is a preorder for instance:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Definition</span> <span class="org-function-name">PWeaker</span> (<span class="org-variable-name">P1 P2</span>: Pred): <span class="org-type">Prop</span> := <span class="org-type">forall</span> <span class="org-variable-name">s</span>, P2 s -&gt; P1 s.

<span class="org-keyword">Lemma</span> <span class="org-function-name">PWeaker_reflexive</span>: <span class="org-type">forall</span> <span class="org-variable-name">P</span>, P &#8838; P.
<span class="org-keyword">Proof</span>.
  go.
<span class="org-keyword">Qed</span>.

<span class="org-keyword">Lemma</span> <span class="org-function-name">PWeaker_trans</span>: <span class="org-type">forall</span> P1 P2 P3 (<span class="org-variable-name">H1</span>: P1 &#8838; P2) (<span class="org-variable-name">H2</span>: P2 &#8838; P3), P1 &#8838; P3.
<span class="org-keyword">Proof</span>.
  <span class="org-proof-tactics-name">intros</span> P1 P2 P3 H1 H2 s H3; <span class="org-proof-tactics-name">apply</span> H1,H2,H3.
<span class="org-keyword">Qed</span>.

<span class="org-keyword">Add Parametric Relation</span>: Pred PWeaker
    <span class="org-coq-solve-tactics">reflexivity</span> proved <span class="org-coq-solve-tactics">by</span> PWeaker_reflexive
    <span class="org-proof-tactics-name">transitivity</span> proved <span class="org-coq-solve-tactics">by</span> PWeaker_trans
      <span class="org-type">as</span> PWeaker_preorder.
</pre>
</div>

<p>
In this case naturally <code>symmetry</code> will not work.  Note that you are not
required to provide the appropriate proof term directly in the relation
declaration, you may use wildcards for coq to require the proofs
interactively.
</p>

<p>
Remark: As said earlier, what is really going on is the typeclass
mechanism. So all this is simply sugar for an instance declaration to the
appropriate type class, Equivalence for example in the first case. We could
have written instead:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Require Import</span> Classes.RelationClasses.

<span class="org-keyword">Instance</span> <span class="org-function-name">PEq_equiv</span>: @Equivalence Pred PEq :=
 Equivalence_Reflexive := PEq_reflexive
 Equivalence_Symmetric := PEq_symm
 Equivalence_Transitive := PEq_trans.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Adding morphisms</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
The other typical case in which you might want to extend built-in tactics is
the one of morphisms for which we would like to be able to use
<code>rewrite</code>. Once again, we have syntactic sugar to avoir bothering explicitely
with typeclasses.  In the case of a binary function, it would look like this:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Add Parametric Morphism</span> : f <span class="org-type">with</span>
<span class="org-type">   signature</span> (rel ==&gt; rel ==&gt; rel) <span class="org-type">as</span> foo.
</pre>
</div>

<p>
This one might seem a bit more cryptic. What is going on is that given a
context, we want to be able to substitute a subterm for an other one given
they are related by the relation rel. Said differently, we want to prove that
f is a morphism with respect to rel, or that rel is compatible with f.
</p>

<p>
It is clearer with an example. Say we define the union of two predicates, we
can actually rewrite any equivalent predicates under it.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Require Import</span> Setoid.
<span class="org-keyword">Definition</span> <span class="org-function-name">PJoin</span> P1 P2: Pred := <span class="org-coq-symbol-binder">&#955;</span> <span class="org-variable-name">s</span>, P1 s \/ P2 s.

<span class="org-keyword">Add Parametric Morphism</span> : PJoin <span class="org-type">with</span>
<span class="org-type">   signature</span> (PEq ==&gt; PEq ==&gt; PEq) <span class="org-type">as</span> foo.
<span class="org-keyword">Proof</span>.
  <span class="org-proof-tactics-name">intros</span> Q1 Q1' eq1 Q2 Q2' eq2 s; <span class="org-proof-tactics-name">split</span>; <span class="org-proof-tactics-name">intros</span> H;
    (<span class="org-proof-tactics-name">destruct</span> H; [<span class="org-proof-tactics-name">left</span>; <span class="org-proof-tactics-name">apply</span> eq1; <span class="org-coq-solve-tactics">assumption</span> | <span class="org-proof-tactics-name">right</span>; <span class="org-proof-tactics-name">apply</span> eq2; <span class="org-coq-solve-tactics">assumption</span>]).
<span class="org-keyword">Qed</span>.
</pre>
</div>

<p>
coq asked us to prove that if four predicates are pairwise PEquivalent, their
respective unions are PEquivalent. We therefore now are able to use the
tactic <code>rewrite</code> to rewrite PEquivalences under unions in goals.
</p>

<p>
Note: beware, we only proved the compatibility of PEq with respect to the
union!  coq will complain if we try to rewrite PEquivalence under any other
construction. The (Leibniz) equality has the peculiar property to be
compatible with any context by definition.  
</p>

<p>
Note bis: we have a very symmetric statement in the exemple using PEq
everywhere, but that is not necessary. We could for instance assert
compatibility only on the left by replacing the second PEq by an eq. An other
reason of uniformity in the example is that the codomain of the function
PJoin is the same as its arguments, but once again it could be otherwise. It
notably is common to end up in Prop and therefore be interested in a result
where the last PEq is replaced by iff: the proposition obtained after
rewriting is guaranteed to be equivalent.
</p>

<p>
Finally, as was the case with relations, we can instead explicitely declare
the adequate instance. The Typeclass at use here is Proper:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Instance</span> <span class="org-function-name">foo</span>: Proper (PEq ==&gt; PEq ==&gt; PEq) PJoin.
<span class="org-keyword">Proof</span>.
  <span class="org-proof-tactics-name">intros</span> Q1 Q1' eq1 Q2 Q2' eq2 s; <span class="org-proof-tactics-name">split</span>; <span class="org-proof-tactics-name">intros</span> H;
    (<span class="org-proof-tactics-name">destruct</span> H; [<span class="org-proof-tactics-name">left</span>; <span class="org-proof-tactics-name">apply</span> eq1; <span class="org-coq-solve-tactics">assumption</span> | <span class="org-proof-tactics-name">right</span>; <span class="org-proof-tactics-name">apply</span> eq2; <span class="org-coq-solve-tactics">assumption</span>]).
<span class="org-keyword">Qed</span>.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Using hint databases</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Hint databases from the standard library</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
The auto (or its existential variant) tactics tries by default to solve a goal by
exploring proofs trees, up to a fixed depth, that could be built using
a fixed set of rules.
These rules are defined in a so-called database, named core,
essentially trying to unfold a few arithmetic and boolean functions
from the standard library, and trying to apply a few lemmas and
constructor over the elementary logical connectives. Its detail can be
printed through the command:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Print</span> HintDb core.
</pre>
</div>

<p>
However, the auto tactics can be prompted to use another hint
database. Are predefined the following, whose detail can be printed as
seen previously: arith, zarith, bool, datatypes, sets and
typeclass<sub>instances</sub>. Note that the last one is automatically enriched when
registering new instances for a typeclass, and used during resolution.
The syntax to use a specific database is the following:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tactics-name">auto</span> <span class="org-type">with</span> db1 ... db2.
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> User-defined databases</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
One can also define its own databases, for instance to reduce a user
defined expression to its normal-form via rewriting lemmas. 
Its creation is done through the Create HintDb command:
</p>
<div class="org-src-container">

<pre class="src src-coq">Create HintDb my_lovely_db.
</pre>
</div>
<p>
The user can then enrich the database by adding hints to it. A hint is
a lemma (actually more generally a term) and a way to use it:
</p>
<ul class="org-ul">
<li>by applying it (adds "simple apply term" to the db): keyword Resolve
</li>
<li>by succeeding applying it (adds "simple apply term; trivial" to the
db): keyword Immediate
</li>
<li>by adding constructors of a type as Resolve hints: keyword
Constructors
</li>
<li>by allowing auto to unfold a definition: keyword Unfold
</li>
<li>by applying any tactic: keyword Extern. 
</li>
</ul>

<p>
For instance:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Hint Resolve</span> <span class="org-variable-name">lemma1 lemma2</span>: my_lovely_db.
</pre>
</div>

<p>
For more details: <a href="https://coq.inria.fr/refman/Reference-Manual010.html#sec395">https://coq.inria.fr/refman/Reference-Manual010.html#sec395</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Computation</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> Compute</h4>
</div>
<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> cbv</h4>
</div>
<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3"><span class="section-number-4">2.3.3</span> cbn</h4>
</div>
<div id="outline-container-sec-2-3-4" class="outline-4">
<h4 id="sec-2-3-4"><span class="section-number-4">2.3.4</span> Simpl</h4>
</div>
<div id="outline-container-sec-2-3-5" class="outline-4">
<h4 id="sec-2-3-5"><span class="section-number-4">2.3.5</span> NoteReflexivity</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
Reflexivity does more than simpl, it notably tries to unfold definitions.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Notations</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Useful notations from the standard library</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Importing the utf8 standard library defines a few convenient utf8-based notations. In particular an elegant way to define anonymous functions:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Require Import</span> Utf8.

<span class="org-type">let</span> f := <span class="org-coq-symbol-binder">&#955;</span> <span class="org-variable-name">x y</span>, x + y.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Precedence levels</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Go from 0 (tightest) to 100, with an additionnal special 200.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Associativity</h3>
<div class="outline-text-3" id="text-3-3">
<p>
No associativity
Left associativity
Right associativity
</p>
</div>
</div>
</div>



<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Working with Ltac</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Matching on hypotheses and conclusions</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Hypotheses</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Looking for an hypothesis of the form P x y, for any x and y.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-type">match</span> goal <span class="org-type">with</span>
  <span class="org-function-name">H</span> : P ?x ?y |- _ =&gt; <span class="org-proof-tactics-name">destruct</span> H; <span class="org-proof-tactics-name">auto</span>
<span class="org-type">end</span>.
</pre>
</div>
<p>
This will fail if no such hypothesis exists.
You can add <code>try</code> in front of it.
</p>

<p>
To match <b>all</b> such hypotheses, add <code>repeat</code>.
</p>

<p>
The following example shows how to use hypotheses matching to remove duplicates in hypotheses.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Goal</span> <span class="org-function-name">P</span> x y -&gt; P x y -&gt; P x z -&gt; P x z -&gt; P x z -&gt; P y z.
<span class="org-keyword">Proof</span>.
  <span class="org-proof-tactics-name">intros</span>.

  <span class="org-proof-tacticals-name">repeat</span> <span class="org-type">match</span> goal <span class="org-type">with</span>
    <span class="org-function-name">H1</span> : P ?x ?y,
        H2: P ?x ?y |- _ =&gt; <span class="org-proof-tactics-name">clear</span> H1
  <span class="org-type">end</span>.
<span class="org-keyword">Qed</span>.
</pre>
</div>

<p>
We try to match two hypotheses of the form <code>P ?x ?y</code>. The pattern matching is
 strong enough to express that H1 and H2 must refer to the same x and y.
H1 and H2 are guaranteed to be different though.
</p>

<p>
It is also possible to match part of an hypothesis.
Using <code>context</code>:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-type">match</span> goal <span class="org-type">with</span>
  <span class="org-function-name">H</span> : context [P ?x ?y] |- _ =&gt; <span class="org-comment-delimiter">(* </span><span class="org-comment">do stuff </span><span class="org-comment-delimiter">*)</span>
<span class="org-type">end</span>.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Conclusions</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
The matching can also be made on the conlusion of the goal (after <code>|-</code>):
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-type">match</span> goal <span class="org-type">with</span>
  |- context [P ?x ?y] =&gt; <span class="org-comment-delimiter">(* </span><span class="org-comment">do stuff </span><span class="org-comment-delimiter">*)</span>
<span class="org-type">end</span>.
</pre>
</div>

<p>
Of course, multiple patterns can be matched.
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tacticals-name">repeat</span> <span class="org-type">match</span> goal <span class="org-type">with</span>
  <span class="org-function-name">H</span> : context [P ?x ?y] |- _ =&gt; <span class="org-comment-delimiter">(* </span><span class="org-comment">do stuff </span><span class="org-comment-delimiter">*)</span>
| |- context [P ?x ?y] =&gt; <span class="org-comment-delimiter">(* </span><span class="org-comment">do stuff </span><span class="org-comment-delimiter">*)</span>
<span class="org-type">end</span>.
</pre>
</div>
<p>
This will loop as long as either the hypotheses or the conclusion contain a term matching <code>P ?x ?y</code>.
Be sure to remove the matching hypotheses to enforce termination.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Generate fresh names</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Sometimes we need to generate fresh names inside tactics:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-type">let</span> n := fresh <span class="org-type">in</span> <span class="org-comment-delimiter">(* </span><span class="org-comment">generate new name, probably H0, H1, H2 </span><span class="org-comment-delimiter">*)</span>
<span class="org-proof-tactics-name">intro</span> n

<span class="org-type">let</span> n := fresh H <span class="org-type">in</span> <span class="org-comment-delimiter">(* </span><span class="org-comment">generate new name, based on the name of H </span><span class="org-comment-delimiter">*)</span>
<span class="org-proof-tactics-name">intro</span> n

<span class="org-type">let</span> n := fresh <span class="org-string">"H"</span> <span class="org-type">in</span> <span class="org-comment-delimiter">(* </span><span class="org-comment">generate new name, based on the given string "H" </span><span class="org-comment-delimiter">*)</span>
<span class="org-proof-tactics-name">intro</span> n
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Print Ltac</h3>
<div class="outline-text-3" id="text-4-3">
<p>
One can view the Ltac code of a tactic (when it's actually written in Ltac).
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Print</span> <span class="org-keyword">Ltac</span> <span class="org-function-name">inv</span>.

---&gt;
<span class="org-keyword">Ltac</span> <span class="org-function-name">inv</span> H := <span class="org-proof-tactics-name">inversion</span> H; <span class="org-proof-tactics-name">clear</span> H; <span class="org-proof-tactics-name">subst</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Working with PG</h3>
<div class="outline-text-3" id="text-4-4">
<p>
One can add custom keybindings to Emacs / PG.
For example, to see the Ltac code of a tactic (see previous section), we can define the following Emacs lisp code in the appropriate file (~/.emacs= in my case)
</p>

<div class="org-src-container">

<pre class="src src-elisp">(<span class="org-keyword">defun</span> <span class="org-function-name">coq-Print-Ltac</span> (withprintingall)
  <span class="org-doc">"Ask for a tactic and Print Ltac it."</span>
  (interactive <span class="org-string">"P"</span>)
  (<span class="org-keyword">if</span> withprintingall
      (coq-ask-do-show-all <span class="org-string">"Print Ltac"</span> <span class="org-string">"Print Ltac"</span>)
    (coq-ask-do <span class="org-string">"Print Ltac"</span> <span class="org-string">"Print Ltac"</span>)))

(global-set-key (kbd <span class="org-string">"C-c C-$"</span>) 'coq-Print-Ltac)
</pre>
</div>

<p>
(PW: I should investigate what occurences of "Print Ltac" stand for what)
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Miscellaneous useful tricks</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Keeping track of the ongoing case</h3>
<div class="outline-text-3" id="text-5-1">
<p>
If proceeding by induction or case studies over an inductive case,
say a semantic judgment, it can be hard to spot which case we end
up in. A useful hack is to keep track of a discriminating
parameter. Assuming for example that we are about to inverse a
judgment such as (i, σ) → (i', σ'), simply use the following
tactics beforehand:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tactics-name">set</span> (ii := i)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Duplicating an hypothesis</h3>
<div class="outline-text-3" id="text-5-2">
</div><div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> With remember</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Ltac</span> <span class="org-function-name">dup</span> H :=
<span class="org-type">let</span> H' := fresh <span class="org-string">"H"</span> <span class="org-type">in</span>
remember H <span class="org-type">as</span> H'; <span class="org-proof-tactics-name">clear</span> HeqH'.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2"><span class="section-number-4">5.2.2</span> With generalize dependent</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Ltac</span> <span class="org-function-name">dup</span> H :=
<span class="org-type">let</span> H' := fresh <span class="org-string">"H"</span> <span class="org-type">in</span>
<span class="org-proof-tactics-name">generalize dependent</span> H; <span class="org-proof-tactics-name">intros</span> H'.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-3" class="outline-4">
<h4 id="sec-5-2-3"><span class="section-number-4">5.2.3</span> With assert</h4>
<div class="outline-text-4" id="text-5-2-3">
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Ltac</span> <span class="org-function-name">dup</span> H :=
<span class="org-type">let</span> n := fresh H <span class="org-type">in</span>
<span class="org-proof-tactics-name">assert</span> (n := H)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Show the axioms used for a given lemma</h3>
<div class="outline-text-3" id="text-5-3">
<p>
To show what axioms a given lemma depends on, one can use the following vernacular command
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Print</span> Assumptions my_lemma.
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Arguments</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Implicit arguments</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Implicit arguments are treated the same way as if provided as an _, but systematically.
We can declare them at define time by putting curly brackets around the argument.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Inductive</span> <span class="org-function-name">list</span> {<span class="org-variable-name">A</span> : <span class="org-type">Type</span>} : <span class="org-type">Type</span> :=
 | nil : list
 | cons : A -&gt; list -&gt; list.
</pre>
</div>

<p>
Afterwards, through the Arguments directive: name and list of arguments, curly
brackets for the ones to be inferred.
</p>

<p>
Use an @ to disable implicit arguments locally.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Definition</span> <span class="org-function-name">l</span> : @list nat := ... .
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Arguments renaming</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Arguments can be used to rename arguments using the rename flag (:rename. at the end of the command).
(PW: explain? example?)
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Generalize dependent versus generalize versus revert</h2>
<div class="outline-text-2" id="text-7">
<p>
Starting from a goal
</p>
<div class="org-src-container">

<pre class="src src-coq">a, b : A
EQ : a = b
---------
  b = a
</pre>
</div>

<p>
One can use different tactics to move hypotheses from the context to the goal.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tactics-name">revert</span> EQ

a, b : A
---------
a = b -&gt; b = a
</pre>
</div>
<p>
OR
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tactics-name">generalize</span> EQ

a, b : A
EQ : a = b
---------
a = b -&gt; b = a
</pre>
</div>

<p>
Notice that the generalized hypothesis is still present in the context, contrary to the reverted one.
</p>

<p>
We can also generalize terms of type in Type.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tactics-name">generalize</span> a

a, b : A
EQ : a = b
---------
<span class="org-type">forall</span> <span class="org-variable-name">a0</span>: A, b = a0
</pre>
</div>

<p>
Here we have lost some information, because the <code>a</code> in the context is no longer related to the new one.
This situation is solved using generalize dependent.
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-proof-tactics-name">generalize dependent</span> a

b : A
---------
<span class="org-type">forall</span> <span class="org-variable-name">a</span> : A, a = b -&gt; b = a
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Intro patterns</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> With square brackets</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Conjunction: just a list with no separators
Ex: <code>[H1 [H2 H3]]</code> or <code>(H1 &amp; H2 &amp; H3)</code>
Disjunction: <code>|</code>
Ex: <code>[H1 | H2]</code>
</p>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Tricks</h3>
<div class="outline-text-3" id="text-8-2">
<p>
&lt;- or -&gt; to rewrite directly an equality.
_ clear the hypothesis directly
? to let coq choose the name
</p>
</div>
</div>
</div>


<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Pattern matching. Unify with intro patterns and talk about the let, let with the backstick</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> A particular case of pattern matching, the let-binding</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Coq does not allow pattern matching over arguments of a function, as opposed to OCaml, even if the inductive type of this constructor admits a unique constructor. One can avoid an arguably heavy match using the let-binding construct:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Definition</span> <span class="org-function-name">&#960;1</span> (<span class="org-variable-name">A B</span>: <span class="org-type">Type</span>) (<span class="org-variable-name">x</span>: A * B) -&gt; A :=
<span class="org-type">let</span> (a,b) := x <span class="org-type">in</span> a.
</pre>
</div>

<p>
Note however that by default, you can only destruct one layer of the argument. Using a tick allows you to destruct at arbitrary depth:
</p>
<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Definition</span> <span class="org-function-name">&#960;11</span> (<span class="org-variable-name">A B C</span>: <span class="org-type">Type</span>) (<span class="org-variable-name">x</span>: (A * B) * C) -&gt; A :=
<span class="org-type">let</span> '((a,b),c) := x <span class="org-type">in</span> a.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Switching and selecting goals</h2>
<div class="outline-text-2" id="text-10">
<p>
When several subgoals are left to solve, it is possible to solve some goals
before others (either because you don't feel in the mood for a given subgoal or
because solving some goal will instantiate lots of existential variables, making
it easier to solve the remaining goals afterwards).
</p>
</div>

<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> Switching to a specific goal</h3>
<div class="outline-text-3" id="text-10-1">
<p>
You can switch to solve goal <code>num</code> with the <code>Focus</code> vernacular command:
</p>

<div class="org-src-container">

<pre class="src src-coq"><span class="org-keyword">Focus</span> 2.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> Goal selectors.</h3>
<div class="outline-text-3" id="text-10-2">
<p>
When the proof of the n-th goal is fairly easy, i.e. it is doable in a single
tactic, we can use goal selectors that look more lightweight.
</p>

<p>
To apply tactic <code>tac</code> to the n-th subgoal:
</p>
<div class="org-src-container">

<pre class="src src-coq">n: tac.
</pre>
</div>
</div>

<div id="outline-container-sec-10-2-1" class="outline-4">
<h4 id="sec-10-2-1"><span class="section-number-4">10.2.1</span> In 8.5, the all: selector</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
In Coq 8.5, the <code>all:</code> selector applies a given tactic to all goals.  This seems
very handy in cases where a <code>eapply</code> has generated lots of existentials, most of
which would be solved in a particular subgoal. The strategy I would use here is
to apply some tactic to the most discriminant subgoal and then call <code>auto</code> or
<code>eauto</code> on the rest of the subgoals.
</p>

<div class="org-src-container">

<pre class="src src-coq">n: tac.
all: <span class="org-proof-tactics-name">auto</span>.
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Emacs extensions: Proof-General and Company-coq</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> Proof-General</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Proof-General is an Emacs interface for proof assistants such as Coq. The latest version is available on <a href="https://github.com/ProofGeneral/PG">GitHub</a>.
</p>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> Company-coq</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Company-coq is an extension for Proof-General's Coq mode. It is available through <a href="http://melpa.org/#/getting-started">MELPA</a>. One of its most interesting feature is prettification.
For example, adding the following bits of code into your `~/.emacs` will visually replace all <code>alpha</code> with an <code>α</code>.
</p>
<div class="org-src-container">

<pre class="src src-elisp">(add-hook 'coq-mode-hook #'company-coq-initialize)
(add-hook 'coq-mode-hook
          (<span class="org-keyword">lambda</span> ()
            (set (make-local-variable 'prettify-symbols-alist)
                 '((<span class="org-string">"Admitted."</span> . ?&#128561;) (<span class="org-string">"admit."</span> . ?&#128561;)
  (<span class="org-string">"Alpha"</span> . ?&#913;) (<span class="org-string">"Beta"</span> . ?&#914;) (<span class="org-string">"Gamma"</span> . ?&#915;)
  (<span class="org-string">"Delta"</span> . ?&#916;) (<span class="org-string">"Epsilon"</span> . ?&#917;) (<span class="org-string">"Zeta"</span> . ?&#918;)
  (<span class="org-string">"Eta"</span> . ?&#919;) (<span class="org-string">"Theta"</span> . ?&#920;) (<span class="org-string">"Iota"</span> . ?&#921;)
  (<span class="org-string">"Kappa"</span> . ?&#922;) (<span class="org-string">"Lambda"</span> . ?&#923;) (<span class="org-string">"Mu"</span> . ?&#924;)
  (<span class="org-string">"Nu"</span> . ?&#925;) (<span class="org-string">"Xi"</span> . ?&#926;) (<span class="org-string">"Omicron"</span> . ?&#927;)
  (<span class="org-string">"Pi"</span> . ?&#928;) (<span class="org-string">"Rho"</span> . ?&#929;) (<span class="org-string">"Sigma"</span> . ?&#931;)
  (<span class="org-string">"Tau"</span> . ?&#932;) (<span class="org-string">"Upsilon"</span> . ?&#933;) (<span class="org-string">"Phi"</span> . ?&#934;)
  (<span class="org-string">"Chi"</span> . ?&#935;) (<span class="org-string">"Psi"</span> . ?&#936;) (<span class="org-string">"Omega"</span> . ?&#937;)
  (<span class="org-string">"alpha"</span> . ?&#945;) (<span class="org-string">"beta"</span> . ?&#946;) (<span class="org-string">"gamma"</span> . ?&#947;)
  (<span class="org-string">"delta"</span> . ?&#948;) (<span class="org-string">"epsilon"</span> . ?&#949;) (<span class="org-string">"zeta"</span> . ?&#950;)
  (<span class="org-string">"eta"</span> . ?&#951;) (<span class="org-string">"theta"</span> . ?&#952;) (<span class="org-string">"iota"</span> . ?&#953;)
  (<span class="org-string">"kappa"</span> . ?&#954;) (<span class="org-string">"lambda"</span> . ?&#955;) (<span class="org-string">"mu"</span> . ?&#956;)
  (<span class="org-string">"nu"</span> . ?&#957;) (<span class="org-string">"xi"</span> . ?&#958;) (<span class="org-string">"omicron"</span> . ?&#959;)
  (<span class="org-string">"pi"</span> . ?&#960;) (<span class="org-string">"rho"</span> . ?&#961;) (<span class="org-string">"sigma"</span> . ?&#963;)
  (<span class="org-string">"tau"</span> . ?&#964;) (<span class="org-string">"upsilon"</span> . ?&#965;) (<span class="org-string">"phi"</span> . ?&#966;)
  (<span class="org-string">"chi"</span> . ?&#967;) (<span class="org-string">"psi"</span> . ?&#968;) (<span class="org-string">"omega"</span> . ?&#969;)
  ))))
</pre>
</div>
<p>
You will however need to use a font that can handle unicode. For example on OS X, you may need to add the following code into your `~/.emacs`:
</p>
<div class="org-src-container">

<pre class="src src-elisp">(set-fontset-font t 'unicode (font-spec <span class="org-builtin">:name</span> <span class="org-string">"Apple Color Emoji"</span>) nil 'append)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> <span class="todo TODO">TODO</span> : PG, companycoq, useful commands</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Platypus</p>
<p class="date">Created: 2016-03-04 Fri 17:47</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.4)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
