* Computation
** Eval
*** Compute
*** cbv
*** cbn (8.5)
** Simpl
** Reflexivity 
   Reflexivity does more than simpl, it notably tries to unfold definitions. 
   

* Intro patterns
** With square brackets
   Conjunction: just a list with no separators
   Ex: [H1 [H2 H3]] or (H1 & H2 & H3)
   Disjunction: |
   Ex: [H1 | H2]
** Tricks
   <- or -> to rewrite directly an equality. 
   _ clear the hypothesis directly
   ? to let Coq choose the name


* Notations
** Precedence levels
   Go from 0 (tightest) to 100, with an additionnal special 200.
** Associativity
   No associativity
   Left associativity
   Right associativity


* The Case tactic
  From Software Foundation, used to keep track of the ongoing case

**
#+BEGIN_SRC coq
   Require String. Open Scope string_scope.
   
   Ltac move_to_top x :=
   match reverse goal with
  | H : _ | - _ => try move x after H |
  end.
  
  Tactic Notation "assert_eq" ident(x) constr(v) :=
  let H := fresh in
  assert (x = v) as H by reflexivity;
  clear H.
  
  Tactic Notation "Case_aux" ident(x) constr(name) :=
  first [
  set (x := name); move_to_top x
  | assert_eq x name; move_to_top x
  | fail 1 "because we are working on a different case" ].
  
  Tactic Notation "Case" constr(name) := Case_aux Case name.
  Tactic Notation "SCase" constr(name) := Case_aux SCase name.
  Tactic Notation "SSCase" constr(name) := Case_aux SSCase name.
  Tactic Notation "SSSCase" constr(name) := Case_aux SSSCase name.
  Tactic Notation "SSSSCase" constr(name) := Case_aux SSSSCase name.
  Tactic Notation "SSSSSCase" constr(name) := Case_aux SSSSSCase name.
  Tactic Notation "SSSSSSCase" constr(name) := Case_aux SSSSSSCase name.
  Tactic Notation "SSSSSSSCase" constr(name) := Case_aux SSSSSSSCase name.
#+END_SRC


* Arguments
** Implicit arguments
  Implicit arguments are treated the same way as if provided as an _, but systematically.
  We can declare them at define time by putting curly brackets around the argument.
  
  #+BEGIN_SRC coq
    Inductive list {A : Type} : Type :=
     | nil : list 
     | cons : A -> list -> list.           
  #+END_SRC

  Afterwards, through the Arguments directive: name and list of arguments, curly
  brackets for the ones to be inferred.

  Use an @ to disable implicit arguments locally.

  #+BEGIN_SRC coq
   Definition l : @list nat := ... .
  #+END_SRC
  

** Arguments renaming
Arguments can be used to rename arguments using the rename flag (:rename. at the end of the command).
(PW: explain? example?)


* Generalize dependent versus generalize versus revert

Starting from a goal
#+BEGIN_SRC coq
  a, b : A
  EQ : a = b
  ---------
    b = a
#+END_SRC

One can use different tactics to move hypotheses from the context to the goal.

#+BEGIN_SRC coq
  revert EQ

  a, b : A
  ---------
  a = b -> b = a

#+END_SRC
OR
#+BEGIN_SRC coq
  generalize EQ 

  a, b : A
  EQ : a = b
  ---------
  a = b -> b = a
#+END_SRC

Notice that the generalized hypothesis is still present in the context, contrary to the reverted one.

We can also generalize terms of type in Type.

#+BEGIN_SRC coq
  generalize a

  a, b : A
  EQ : a = b
  ---------
  forall a0: A, b = a0
#+END_SRC

Here we have lost some information, because the a in the context is no longer related to the new one.
This situation is solved using generalize dependent.

#+BEGIN_SRC coq
  generalize dependent a

  b : A
  ---------
  forall a : A, a = b -> b = a
#+END_SRC


* Duplicating an hypothesis
** With remember
#+BEGIN_SRC coq
   Ltac dup H := 
   let H' := fresh "H" in 
   remember H as H'; clear HeqH'.
#+END_SRC

** With generalize dependent
#+BEGIN_SRC coq
   Ltac dup H :=
   let H' := fresh "H" in
   generalize dependent H; intros H'.
#+END_SRC
   

* Working with Ltac

** Matching on hypotheses and conclusions
*** Hypotheses
Looking for an hypothesis of the form P x y, for any x and y.

#+BEGIN_SRC coq
  match goal with
    H : P ?x ?y |- _ => destruct H; auto
  end.
#+END_SRC
This will fail if no such hypothesis exists.
You can add ~try~ in front of it.

To match *all* such hypotheses, add ~repeat~.


The following example shows how to use hypotheses matching to remove duplicates in hypotheses.

#+BEGIN_SRC coq
  Goal P x y -> P x y -> P x z -> P x z -> P x z -> P y z.
  Proof.
    intros.

    repeat match goal with
      H1 : P ?x ?y,
          H2: P ?x ?y |- _ => clear H1
    end.
  Qed.
#+END_SRC

We try to match two hypotheses of the form P ?x ?y. The pattern matching is
 strong enough to express that H1 and H2 must refer to the same x and y.
H1 and H2 are guaranteed to be different though.

It is also possible to match part of an hypothesis.
Using ~context~:
#+BEGIN_SRC coq
match goal with
  H : context [P ?x ?y] |- _ => (* do stuff *)
end.
#+END_SRC

*** Conclusions

The matching can also be made on the conlusion of the goal (after ~|-~):
#+BEGIN_SRC coq
match goal with
  |- context [P ?x ?y] => (* do stuff *)
end.
#+END_SRC

Of course, multiple patterns can be matched.
#+BEGIN_SRC coq
repeat match goal with
  H : context [P ?x ?y] |- _ => (* do stuff *)
| |- context [P ?x ?y] => (* do stuff *)
end.
#+END_SRC
This will loop as long as either the hypotheses or the conclusion contain a term matching ~P ?x ?y~.
Be sure to remove the matching hypotheses to enforce termination.



** Generate fresh names

Sometimes we need to generate fresh names inside tactics:
#+BEGIN_SRC coq
  let n := fresh in (* generate new name, probably H0, H1, H2 *)
  intro n

  let n := fresh H in (* generate new name, based on the name of H *)
  intro n

  let n := fresh "H" in (* generate new name, based on the given string "H" *)
  intro n

#+END_SRC

** Print Ltac
One can view the Ltac code of a tactic (when it's actually written in Ltac).
#+BEGIN_SRC coq
  Print Ltac inv.

  --->
  Ltac inv H := inversion H; clear H; subst
#+END_SRC

** Working with PG

One can add custom keybindings to Emacs / PG.
For example, to see the Ltac code of a tactic (see previous section), we can define the following Emacs lisp code in the appropriate file (~/.emacs= in my case)

#+BEGIN_SRC elisp

(defun coq-Print-Ltac (withprintingall)
  "Ask for a tactic and Print Ltac it."
  (interactive "P")
  (if withprintingall
      (coq-ask-do-show-all "Print Ltac" "Print Ltac")
    (coq-ask-do "Print Ltac" "Print Ltac")))

(global-set-key (kbd "C-c C-$") 'coq-Print-Ltac)

#+END_SRC

(PW: I should investigate what occurences of "Print Ltac" stand for what)


* Show the axioms used for a given lemma

To show what axioms a given lemma depends on, one can use the following vernacular command

#+BEGIN_SRC coq
Print Assumptions my_lemma.
#+END_SRC

* Using tactics like reflexivity over user built relations
  The goal here is to be able to use Coq's built-in tactics over other relations than iff and eq, in particular relations that you have defined yourself.
** Adding equivalence relations, preorder, etc...

   The inner mechanism going on when using tactics like reflexivity, transitivity or symmetry are typeclasses. However Coq allows a particular facilities to declare new relations without digging into this.
   The syntax goes roughly as follows:

   #+BEGIN_SRC coq
   Add Parametric Relation (A: Type): A (@R A)
   reflexivity proved by ...
   symmetry proved by ...
   transitivity proved by ...
   as R_is_an_equivalence_relation.
   #+END_SRC 

   Note that you naturally only want to take A as a parameter if your relation is indeed polymorphic.
   For instance, suppose you need to manipulate predicates over program states up to propositional extentionnal equivalence. This relation is an equivalence relation, so you might want to declare is as so.

   #+BEGIN_SRC coq
   Axiom state: Type.
   Definition Pred: state -> Prop.
   Definition PEq (P1 P2: Pred): Prop := forall x, P1 x <-> P2 x.
   Lemma PEq_reflexive: forall P, P ≡ P.
   Proof.
     intros P s; go.
   Qed.

   Lemma PEq_trans: forall P1 P2 P3 (H1: P1 ≡ P2) (H2: P2 ≡ P3),
       P1 ≡ P3.
     intros P1 P2 P3 H1 H2 s; split; intros H3; [apply H2, H1 | apply H1,H2]; assumption.
   Qed. 
  
   Lemma PEq_symm: forall P1 P2 (H: P1 ≡ P2), P2 ≡ P1.
   Proof.
     intros P1 P2 H s; split; intros H'; apply H; assumption.
   Qed.

   Add Parametric Relation: Pred PEq
       reflexivity proved by PEq_reflexive
       symmetry proved by PEq_symm
       transitivity proved by PEq_trans
         as PEq_equiv.   
    
   #+END_SRC

   We now are able to prove goals such that (forall P: Pred, PEq P P) with a simpl (intros P; reflexivity). Same goes for transitivity and symmetry.

   Note that we can also only declare some of those properties, declaring that a relation is a preorder for instance:

   #+BEGIN_SRC coq
   Definition PWeaker (P1 P2: Pred): Prop := forall s, P2 s -> P1 s.

   Lemma PWeaker_reflexive: forall P, P ⊆ P.
   Proof.
     go.
   Qed.

   Lemma PWeaker_trans: forall P1 P2 P3 (H1: P1 ⊆ P2) (H2: P2 ⊆ P3), P1 ⊆ P3.
   Proof.
     intros P1 P2 P3 H1 H2 s H3; apply H1,H2,H3.
   Qed.

   Add Parametric Relation: Pred PWeaker
       reflexivity proved by PWeaker_reflexive
       transitivity proved by PWeaker_trans
         as PWeaker_preorder.   
   #+END_SRC

   In this case naturally symmetry will not work.
   Note that you are not obligated to provide directly the appropriate proof term in the relation declaration, you may use wildcards for Coq to ask you the proofs interactively.

   Remark: As said earlier, what is really going on is the typeclass mechanism. So all this is simply sugar for an instance declaration to the appropriate type class, Equivalence for instance in the first case. We could have written instead:

   #+BEGIN_SRC coq
   Require Import Classes.RelationClasses.

   Instance PEq_equiv: @Equivalence Pred PEq :=
    Equivalence_Reflexive := PEq_reflexive
    Equivalence_Symmetric := PEq_symm
    Equivalence_Transitive := PEq_trans. 
   #+END_SRC 

** Adding morphisms

   The other typical case in which one you might want to extend in built tactics is the one of morphisms for which we would like to be able to use rewrite. Once again, we have syntactic sugar to avoir bothering explicitely with typeclasses.
   In the case of a binary function, it would look like this:

   #+BEGIN_SRC coq
   Add Parametric Morphism : f with
      signature (rel ==> rel ==> rel) as foo.   
   #+END_SRC
   
   This one might seem a bit more cryptic. What is going on is that given a context, we want to be able to substitute a subterm for an other one given they are related by the relation rel. Said differently, want to prove that f is a morphism with respect to rel, or that rel is compatible with f.

   It is clearer with an example. Say we define the union of two predicates, we can actually rewrite any equivalent predicates under it.
 
   #+BEGIN_SRC coq
   
   Require Import Setoid.
   Definition PJoin P1 P2: Pred := λ s, P1 s \/ P2 s.

   Add Parametric Morphism : PJoin with
      signature (PEq ==> PEq ==> PEq) as foo.
   Proof.
     intros Q1 Q1' eq1 Q2 Q2' eq2 s; split; intros H;
       (destruct H; [left; apply eq1; assumption | right; apply eq2; assumption]).
   Qed.

   #+END_SRC

   Coq asked us to prove that if four predicates are PEquivalent by pairs, their respective unions are PEquivalents. We therefore now are able to use the tactic rewrite to rewrite PEquivalences under unions in goals.
   Note: beware, we only proved the compatibility of PEq with respect to the union! Coq will complain if we try to rewrite PEquivalence under any other construction. The (Leibniz) equality has the peculiar property to be compatible with any context by definition.
   Note bis: we have a very symmetric statement in the exemple using PEq everywhere, but that is not necessary. We could for instance assert compatibility only on the left by replacing the second PEq by an eq. An other reason of uniformity in the example is that the codomain of the function PJoin is the same as its arguments, but once again it could be otherwise. It notably is common to end up in Prop and therefore be interested in a result where the last PEq is replaced by iff: the proposition obtain after rewriting is guaranteed to be equivalent.

   Finally, as was the case with relations, we can instead explicitely declare the adequate instance. The Typeclass at use here is Proper:
   
   #+BEGIN_SRC coq

   Instance foo: Proper (PEq ==> PEq ==> PEq) PJoin.
   Proof.
     intros Q1 Q1' eq1 Q2 Q2' eq2 s; split; intros H;
       (destruct H; [left; apply eq1; assumption | right; apply eq2; assumption]).
   Qed.
   
   #+END_SRC
