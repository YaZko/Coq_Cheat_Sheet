* Computation
** Eval
*** Compute
*** cbv
*** cbn (8.5)
** Simpl
** Reflexivity 
   Reflexivity does more than simpl, it notably tries to unfold definitions. 
   

* Intro patterns
** With square brackets
   Conjunction: just a list with no separators
   Ex: [H1 [H2 H3]] or (H1 & H2 & H3)
   Disjunction: |
   Ex: [H1 | H2]
** Tricks
   <- or -> to rewrite directly an equality. 
   _ clear the hypothesis directly
   ? to let Coq choose the name


* Notations
** Precedence levels
   Go from 0 (tightest) to 100, with an additionnal special 200.
** Associativity
   No associativity
   Left associativity
   Right associativity


* The Case tactic
  From Software Foundation, used to keep track of the ongoing case

**
#+BEGIN_SRC Coq
   Require String. Open Scope string_scope.
   
   Ltac move_to_top x :=
   match reverse goal with
  | H : _ | - _ => try move x after H |
  end.
  
  Tactic Notation "assert_eq" ident(x) constr(v) :=
  let H := fresh in
  assert (x = v) as H by reflexivity;
  clear H.
  
  Tactic Notation "Case_aux" ident(x) constr(name) :=
  first [
  set (x := name); move_to_top x
  | assert_eq x name; move_to_top x
  | fail 1 "because we are working on a different case" ].
  
  Tactic Notation "Case" constr(name) := Case_aux Case name.
  Tactic Notation "SCase" constr(name) := Case_aux SCase name.
  Tactic Notation "SSCase" constr(name) := Case_aux SSCase name.
  Tactic Notation "SSSCase" constr(name) := Case_aux SSSCase name.
  Tactic Notation "SSSSCase" constr(name) := Case_aux SSSSCase name.
  Tactic Notation "SSSSSCase" constr(name) := Case_aux SSSSSCase name.
  Tactic Notation "SSSSSSCase" constr(name) := Case_aux SSSSSSCase name.
  Tactic Notation "SSSSSSSCase" constr(name) := Case_aux SSSSSSSCase name.
#+END_SRC

* Arguments
** Implicit arguments
  Implicit arguments are treated the same way as if provided as an _, but systematically.
  We can declare them at define time by putting curly brackets around the argument.
  
  #+BEGIN_SRC Coq
    Inductive list {A : Type} : Type :=
     | nil : list 
     | cons : A -> list -> list.           
  #+END_SRC

  Afterwards, through the Arguments directive: name and list of arguments, curly
  brackets for the ones to be inferred.

  Use an @ to disable implicit arguments locally.

  #+BEGIN_SRC Coq
   Definition l : @list nat := ... .
  #+END_SRC
  

** Arguments renaming
Arguments can be used to rename arguments using the rename flag (:rename. at the end of the command).
(PW: explain? example?)


* Generalize dependent versus generalize versus revert

Starting from a goal
#+BEGIN_SRC Coq
  a, b : A
  EQ : a = b
  ---------
    b = a
#+END_SRC

One can use different tactics to move hypotheses from the context to the goal.

#+BEGIN_SRC Coq
  revert EQ

  a, b : A
  ---------
  a = b -> b = a

#+END_SRC
OR
#+BEGIN_SRC Coq
  generalize EQ 

  a, b : A
  EQ : a = b
  ---------
  a = b -> b = a
#+END_SRC

Notice that the generalized hypothesis is still present in the context, contrary to the reverted one.

We can also generalize terms of type in Type.

#+BEGIN_SRC Coq
  generalize a

  a, b : A
  EQ : a = b
  ---------
  forall a0: A, b = a0
#+END_SRC

Here we have lost some information, because the a in the context is no longer related to the new one.
This situation is solved using generalize dependent.

#+BEGIN_SRC Coq
  generalize dependent a

  b : A
  ---------
  forall a : A, a = b -> b = a
#+END_SRC

* Duplicating an hypothesis
** With remember
#+BEGIN_SRC Coq
   Ltac dup H := 
   let H' := fresh "H" in 
   remember H as H'; clear HeqH'.
#+END_SRC

** With generalize dependent
#+BEGIN_SRC Coq
   Ltac dup H :=
   let H' := fresh "H" in
   generalize dependent H; intros H'.
#+END_SRC
