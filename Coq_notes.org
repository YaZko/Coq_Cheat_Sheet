* Computation
** Eval
*** Compute
*** cbv
*** cbn (8.5)
** Simpl
** Reflexivity 
   Reflexivity does more than simpl, it notably tries to unfold definitions. 
   

* Intro patterns
** With square brackets
   Conjunction: just a list with no separators
   Ex: [H1 [H2 H3]] or (H1 & H2 & H3)
   Disjunction: |
   Ex: [H1 | H2]
** Tricks
   <- or -> to rewrite directly an equality. 
   _ clear the hypothesis directly
   ? to let Coq choose the name


* Notations
** Precedence levels
   Go from 0 (tightest) to 100, with an additionnal special 200.
** Associativity
   No associativity
   Left associativity
   Right associativity


* The Case tactic
  From Software Foundation, used to keep track of the ongoing case

**
#+BEGIN_SRC Coq
   Require String. Open Scope string_scope.
   
   Ltac move_to_top x :=
   match reverse goal with
  | H : _ | - _ => try move x after H |
  end.
  
  Tactic Notation "assert_eq" ident(x) constr(v) :=
  let H := fresh in
  assert (x = v) as H by reflexivity;
  clear H.
  
  Tactic Notation "Case_aux" ident(x) constr(name) :=
  first [
  set (x := name); move_to_top x
  | assert_eq x name; move_to_top x
  | fail 1 "because we are working on a different case" ].
  
  Tactic Notation "Case" constr(name) := Case_aux Case name.
  Tactic Notation "SCase" constr(name) := Case_aux SCase name.
  Tactic Notation "SSCase" constr(name) := Case_aux SSCase name.
  Tactic Notation "SSSCase" constr(name) := Case_aux SSSCase name.
  Tactic Notation "SSSSCase" constr(name) := Case_aux SSSSCase name.
  Tactic Notation "SSSSSCase" constr(name) := Case_aux SSSSSCase name.
  Tactic Notation "SSSSSSCase" constr(name) := Case_aux SSSSSSCase name.
  Tactic Notation "SSSSSSSCase" constr(name) := Case_aux SSSSSSSCase name.
#+END_SRC

* Arguments
** Implicit arguments
  Implicit arguments are treated the same way as if provided as an _, but systematically.
  We can declare them at define time by putting curly brackets around the argument.
  
  #+BEGIN_SRC Coq
    Inductive list {A : Type} : Type :=
     | nil : list 
     | cons : A -> list -> list.           
  #+END_SRC

  Afterwards, through the Arguments directive: name and list of arguments, curly
  brackets for the ones to be inferred.

  Use an @ to disable implicit arguments locally.

  #+BEGIN_SRC Coq
   Definition l : @list nat := ... .
  #+END_SRC
  

** Arguments renaming
Arguments can be used to rename arguments using the rename flag (:rename. at the end of the command).
(PW: explain? example?)


* Generalize dependent versus generalize versus revert

Starting from a goal
#+BEGIN_SRC Coq
  a, b : A
  EQ : a = b
  ---------
    b = a
#+END_SRC

One can use different tactics to move hypotheses from the context to the goal.

#+BEGIN_SRC Coq
  revert EQ

  a, b : A
  ---------
  a = b -> b = a

#+END_SRC
OR
#+BEGIN_SRC Coq
  generalize EQ 

  a, b : A
  EQ : a = b
  ---------
  a = b -> b = a
#+END_SRC

Notice that the generalized hypothesis is still present in the context, contrary to the reverted one.

We can also generalize terms of type in Type.

#+BEGIN_SRC Coq
  generalize a

  a, b : A
  EQ : a = b
  ---------
  forall a0: A, b = a0
#+END_SRC

Here we have lost some information, because the a in the context is no longer related to the new one.
This situation is solved using generalize dependent.

#+BEGIN_SRC Coq
  generalize dependent a

  b : A
  ---------
  forall a : A, a = b -> b = a
#+END_SRC


* Duplicating an hypothesis
** With remember
#+BEGIN_SRC Coq
   Ltac dup H := 
   let H' := fresh "H" in 
   remember H as H'; clear HeqH'.
#+END_SRC

** With generalize dependent
#+BEGIN_SRC Coq
   Ltac dup H :=
   let H' := fresh "H" in
   generalize dependent H; intros H'.
#+END_SRC
   
* Working with Ltac

** Matching on hypotheses and conclusions
*** Hypotheses
Looking for an hypothesis of the form P x y, for any x and y.

#+BEGIN_SRC Coq
  match goal with
    H : P ?x ?y |- _ => destruct H; auto
  end.
#+END_SRC
This will fail if no such hypothesis exists.
You can add ~try~ in front of it.

To match *all* such hypotheses, add ~repeat~.


The following example shows how to use hypotheses matching to remove duplicates in hypotheses.

#+BEGIN_SRC Coq
  Goal P x y -> P x y -> P x z -> P x z -> P x z -> P y z.
  Proof.
    intros.

    repeat match goal with
      H1 : P ?x ?y,
          H2: P ?x ?y |- _ => clear H1
    end.
  Qed.
#+END_SRC

We try to match two hypotheses of the form P ?x ?y. The pattern matching is
 strong enough to express that H1 and H2 must refer to the same x and y.
H1 and H2 are guaranteed to be different though.

It is also possible to match part of an hypothesis.
Using ~context~:
#+BEGIN_SRC Coq
match goal with
  H : context [P ?x ?y] |- _ => (* do stuff *)
end.
#+END_SRC

*** Conclusions

The matching can also be made on the conlusion of the goal (after ~|-~):
#+BEGIN_SRC Coq
match goal with
  |- context [P ?x ?y] => (* do stuff *)
end.
#+END_SRC

Of course, multiple patterns can be matched.
#+BEGIN_SRC Coq
repeat match goal with
  H : context [P ?x ?y] |- _ => (* do stuff *)
| |- context [P ?x ?y] => (* do stuff *)
end.
#+END_SRC
This will loop as long as either the hypotheses or the conclusion contain a term matching ~P ?x ?y~.
Be sure to remove the matching hypotheses to enforce termination.



** Generate fresh names
Sometimes we need to generate fresh names inside tactics (see [[Duplicating an hypothesis]])
#+BEGIN_SRC Coq
  let n := fresh in (* generate new name, probably H0, H1, H2 *)
  intro n

  let n := fresh H in (* generate new name, based on the name of H *)
  intro n

  let n := fresh "H" in (* generate new name, based on the given string "H" *)
  intro n

#+END_SRC

** Print Ltac
One can view the Ltac code of a tactic (when it's actually written in Ltac).
#+BEGIN_SRC Coq
  Print Ltac inv.

  --->
  Ltac inv H := inversion H; clear H; subst
#+END_SRC

** Working with PG

One can add custom keybindings to Emacs / PG.
For example, to see the Ltac code of a tactic (see previous section), we can define the following Emacs lisp code in the appropriate file (~/.emacs= in my case)

#+BEGIN_SRC elisp

(defun coq-Print-Ltac (withprintingall)
  "Ask for a tactic and Print Ltac it."
  (interactive "P")
  (if withprintingall
      (coq-ask-do-show-all "Print Ltac" "Print Ltac")
    (coq-ask-do "Print Ltac" "Print Ltac")))

(global-set-key (kbd "C-c C-$") 'coq-Print-Ltac)

#+END_SRC

(PW: I should investigate what occurences of "Print Ltac" stand for what)
